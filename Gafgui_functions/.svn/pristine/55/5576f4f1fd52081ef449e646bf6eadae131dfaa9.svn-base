function Imcorr = fct_CorrectHomog(Imraw,res,direction); 

% clc;
% clear all;
% close all;
% 
% %This add the functions path
% cpu = computer;
% if strcmp(cpu,'PCWIN')||strcmp(cpu,'PCWIN64')
%     c = '\'; % dos
% else
%     c = '/'; % mac/linux/unix
%     %In the case someone uses a SUN, I don't know if this is correct
% end
% path = cd;
% if (path(max(size(path,1),size(path,2)))==c)
%     path = [path 'Gafgui_functions'];
%     path = [path '..' c 'Gafgui']
% else
%     path = [path c 'Gafgui_functions'];
%     path = [path c '..' c 'Gafgui'];
% end
% addpath(path);
% fct_AddGafguiFctPath();
% handles = fct_initGafgui();
% 
% [ifilename1,ipathname1] = uigetfile({'*.tif'},'Choose .tif image to be corrected');
% 
% [Imraw,res] = fct_read_tif16RGB_image(fct_makecleanfilename(ipathname1,ifilename1),'All');
% 
% figure;
% h = fct_display(Imraw,res);
% 
% direction = questdlg('In which direction do you correct the image?','Direction','Horizontal','Vertical','Horizontal') ;

%%%%%%%%%%%%%%%%%%%%%

[n1,n2,n3] = size(Imraw);

if strcmp(direction,'Vertical')
    Im(:,:,1) = fliplr(transpose(Imraw(:,:,1)));
    Im(:,:,2) = fliplr(transpose(Imraw(:,:,2)));
    Im(:,:,3) = fliplr(transpose(Imraw(:,:,3)));
    maxk = n1;
else
    Im = Imraw;
    maxk = n2;
end
Im = double(Im);

for channel=1:3
    ifilename2{channel} = [];
    ipathname2{channel} = [];
    method{channel} = [];
    button = questdlg(['Do you want to correct the ' sprintf('%s',fct_channeltocolor(channel)) ' channel?'],'Mutichannel correction','Yes','No','Yes') ;
    if strcmp(button,'Yes')
        [ifilename2{channel},ipathname2{channel}] = uigetfile({'*.hmg'},['Choose correction matrix file for the ' sprintf('%s',fct_channeltocolor(channel)) ' channel']);
        button = questdlg(['Which method do you wish to use for the ' sprintf('%s',fct_channeltocolor(channel)) ' channel?'],'Method','Polynomial','Filter','New','Filter') ;
        if strcmp(button,'Polynomial')
            method{channel} = 1;
        elseif strcmp(button,'Filter')
            method{channel} = 0;
        elseif strcmp(button,'New')
            method{channel} = 2;
        end
        fname = fct_makecleanfilename(ipathname2{channel},ifilename2{channel});

        if  (~strcmp(class(fname),'double'))
            if method{channel}==1 %method polynoms

                [p,center,xmin,xmax,smin,smax] = fct_readcorrmatrix(fname);
                nlines = size(Im,1);
                ncols = size(Im,2);
                [x,y] = fct_gridindextopos(nlines,ncols,res);
                k1 = min(find(x > xmin));
                k2 = max(find(x < xmax));
%                 x = x(k1:k2);
%                 I = Im(:,k1:k2,channel);
                x = min(x(k2),max(x(k1),x));
                I = Im(:,:,channel);
                [P,XI,SI] = fct_makecorrmatrix(p,center,x,0:65535/1000:65535);
                figure; mesh(XI,SI,P);
                P = P.*SI;
                center = SI(:,1);
                N = size(I,2);
                h_wait = waitbar(0/N,'Please wait');
                h_fig = figure;
                for j= 1:N
                    %create a lookup table
                    f = P(:,j);
                    if mod(j,100)==0
                        figure(h_fig);
                        plot(f,center,'k');
                        dmb = sprintf('Correction function at x = %f',x(j));
                        title(fct_addbackslash(dmb));
                        xlabel('Raw signal');
                        ylabel('Corrected signal');
                    end
                    im = double(I(:,j));
                    [f,index] = unique(f);
                    im = interp1(f,center(index),im);
                    I(:,j) = uint16(min(max(im,0),65535));
                    %figure(h_wait);
                    waitbar(j/N,h_wait);
                end
                close(h_wait);

            elseif method{channel}==0 %method filter
                [N,xi,F,center] = fct_readcorrmatrix2(fname);
                %h0 = figure('NumberTitle','off','Name','Polynomes');
                %hold on;
                nlines = size(Im,1);
                ncols = size(Im,2);
                xmin = min(xi);
                xmax = max(xi);
                [x,y] = fct_gridindextopos(nlines,ncols,res);
                k1 = min(find(x > xmin));
                k2 = max(find(x < xmax));
%                 x = x(k1:k2);
%                 I = Im(:,k1:k2,channel);
                x = min(x(k2),max(x(k1),x));
                I = Im(:,:,channel);
                [P,XI,SI] = fct_makecorrmatrix2(N,xi,F,x,0:65535/1000:65535);
                P = P.*SI;
                center = SI(:,1);
                N = size(I,2);
                h_wait = waitbar(0/N,'Please wait');
                h_fig = figure;
                for j= 1:N
                    %create lookup table
                    f = P(:,j);
                    if mod(j,100)==0
                        figure(h_fig);
                        plot(f,center,'k');
                        dmb = sprintf('Linear interpolation of correction at x = %f',x(j));
                        title(fct_addbackslash(dmb));
                        xlabel('Raw signal');
                        ylabel('Corrected signal');
                    end
                    im = double(I(:,j));
                    [f,index] = unique(f);
                    im = interp1(f,center(index),im);
                    I(:,j) = uint16(min(max(im,0),65535));
                    %figure(h_wait);
                    waitbar(j/N,h_wait);
                end
                close(h_wait);
            elseif method{channel}==2
                [p,xmin,xmax,x0,smin,smax] = fct_readcorrmatrix3(fname);
                nlines = size(Im,1);
                ncols = size(Im,2);
                [x,y] = fct_gridindextopos(nlines,ncols,res);
                k1 = min(find(x > xmin));
                k2 = max(find(x < xmax));
%                 x = x(k1:k2);
%                 I = Im(:,k1:k2,channel);
                x = min(x(k2),max(x(k1),x));
                I = Im(:,:,channel);
                [P,XI,SI] = fct_makecorrmatrix3(p,x,x0,0:65535/1000:65535);
                %these become the signals you would get as a function of off-axis
                %distance and central signal
                P = P.*SI;
                %central vlaue
                center = SI(:,1) ;
                N = size(I,2);
                h_wait = waitbar(0/N,'Please wait');
                h_fig = figure;
                for j= 1:N
                    %create lookup table: central signal versus what you observe
                    f = P(:,j);
                    if mod(j,100)==0
                        figure(h_fig);
                        plot(f,center,'k');
                        dmb = sprintf('Linear interpolation of correction at x = %f',x(j));
                        title(fct_addbackslash(dmb));
                        xlabel('Raw signal');
                        ylabel('Corrected signal');
                    end
                    im = double(I(:,j));
                    [f,index] = unique(f);
                    im = interp1(f,center(index),im);
                    I(:,j) = uint16(min(max(im,0),65535));
                    %figure(h_wait);
                    waitbar(j/N,h_wait);
                end
                close(h_wait);
            end

            indeces{channel} = [k1 k2];
            close(h_fig);
            
            if strcmp(direction,'Vertical')
                imcorr{channel} = transpose(fliplr(I));
            else
                imcorr{channel} = I;
            end
            clear I;
        else
            error('The image did not get corrected');
        end
    else
        if strcmp(direction,'Vertical')
            imcorr{channel} = transpose(fliplr(Im(:,:,channel)));
        else
            imcorr{channel}  = Im(:,:,channel);
        end
        indeces{channel} = [1 maxk];
    end
end

k1 = max([indeces{1}(1) indeces{2}(1) indeces{3}(1)]);
k2 = min([indeces{1}(2) indeces{2}(2) indeces{3}(2)]);

if strcmp(direction,'Vertical')
    Imcorr(:,:,1) = imcorr{1}(k1:k2,:); imcorr{1} = 0;
    Imcorr(:,:,2) = imcorr{2}(k1:k2,:); imcorr{2} = 0;
    Imcorr(:,:,3) = imcorr{3}(k1:k2,:); imcorr{3} = 0;
else
    Imcorr(:,:,1) = imcorr{1}(:,k1:k2); imcorr{1} = 0;
    Imcorr(:,:,2) = imcorr{2}(:,k1:k2); imcorr{2} = 0;
    Imcorr(:,:,3) = imcorr{3}(:,k1:k2); imcorr{3} = 0;
end
Imcorr = uint16(Imcorr);%only for security